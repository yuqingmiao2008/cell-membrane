<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D细胞膜流动镶嵌模型 | 交互式教学</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #111;
            color: #fff;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #title-card {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            border-left: 5px solid #00aaff;
        }
        h1 {
            font-size: 24px;
            margin: 0 0 5px 0;
        }
        p {
            font-size: 14px;
            margin: 0;
        }
        .label {
            color: #FFF;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 5px;
            visibility: hidden; /* Initially hidden */
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            pointer-events: none; /* Allow clicking through the label */
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .label.visible {
            visibility: visible;
            opacity: 1;
        }
        .label-line {
            position: absolute;
            border-left: 1px dashed #ffffff;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="container">
        <div id="title-card">
            <h1>细胞膜流动镶嵌模型</h1>
            <p>使用鼠标拖动旋转，滚轮缩放</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 1. 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x111111);
        document.getElementById('container').appendChild(renderer.domElement);

        // 2. 添加光照
        // 环境光，提供基础照明
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        // 半球光，模拟天空和地面的光，效果更柔和
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x555555, 1);
        scene.add(hemisphereLight);
        // 方向光，模拟太阳光，产生阴影和高光
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
        
        // 3. 添加控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 15;
        controls.maxDistance = 100;

        // 相机初始位置
        camera.position.set(20, 20, 30);
        
        // 存储所有可交互的物体和它们的标签信息
        const interactiveObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;

        // 创建用于显示标签的DOM元素
        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        document.getElementById('container').appendChild(labelDiv);

        // 创建材质
        const headMaterial = new THREE.MeshStandardMaterial({
            color: 0x00aaff, // 亲水头部: 亮蓝色
            metalness: 0.3,
            roughness: 0.2
        });
        const tailMaterial = new THREE.MeshStandardMaterial({
            color: 0xeeeeee, // 疏水尾部: 浅灰色
            roughness: 0.8
        });
        const integralProteinMaterial = new THREE.MeshStandardMaterial({
            color: 0x9400D3, // 整合蛋白: 紫罗兰色
            metalness: 0.4,
            roughness: 0.4
        });
        const peripheralProteinMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF4500, // 外周蛋白: 橙红色
            metalness: 0.5,
            roughness: 0.3
        });
        const cholesterolMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFF00, // 胆固醇: 黄色
            roughness: 0.6
        });
        const carbohydrateMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF69B4, // 糖链: 粉红色
            metalness: 0.2,
            roughness: 0.5
        });


        // 4. 创建细胞膜模型
        const membraneGroup = new THREE.Group();
        const phospholipidRadius = 0.5;
        const tailLength = 2.5;
        const spacing = 1.2;

        // 创建磷脂双分子层
        for (let i = -15; i < 15; i++) {
            for (let j = -15; j < 15; j++) {
                // 跳过中间区域为蛋白质留出空间
                if (Math.abs(i) < 4 && Math.abs(j) < 4) continue;
                if (i > 5 && i < 9 && j > -3 && j < 3) continue;

                createPhospholipid(i * spacing, j * spacing);
            }
        }
        
        function createPhospholipid(x, z) {
            const group = new THREE.Group();

            // 上层
            const upperHead = new THREE.Mesh(new THREE.SphereGeometry(phospholipidRadius, 16, 16), headMaterial);
            upperHead.position.set(0, tailLength / 2, 0);
            const upperTail1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, tailLength, 8), tailMaterial);
            upperTail1.position.set(-0.2, 0, 0);
            const upperTail2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, tailLength, 8), tailMaterial);
            upperTail2.position.set(0.2, 0, 0);
            const upperLayer = new THREE.Group();
            upperLayer.add(upperHead, upperTail1, upperTail2);
            
            // 下层
            const lowerHead = upperHead.clone();
            const lowerTail1 = upperTail1.clone();
            const lowerTail2 = upperTail2.clone();
            const lowerLayer = new THREE.Group();
            lowerLayer.add(lowerHead, lowerTail1, lowerTail2);
            lowerLayer.rotation.z = Math.PI;

            group.add(upperLayer, lowerLayer);
            group.position.set(x, 0, z);
            membraneGroup.add(group);

            // 为第一个磷脂添加标签，作为示例
            if (x === spacing * -5 && z === spacing * -5) {
                const labelInfo = {
                    element: labelDiv,
                    object: upperHead,
                    text: `<b>磷脂分子 (Phospholipid)</b><br>亲水头部朝外，疏水尾部朝内，<br>构成细胞膜的基本结构。`
                };
                upperHead.userData.labelInfo = labelInfo;
                interactiveObjects.push(upperHead);
            }
        }

        // 创建胆固醇
        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * 35;
            const z = (Math.random() - 0.5) * 35;
             if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
            createCholesterol(x, z);
        }

        function createCholesterol(x, z) {
            const cholesterol = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 0.5), cholesterolMaterial);
            cholesterol.position.set(x, 0, z);
            cholesterol.rotation.y = Math.random() * Math.PI;
            membraneGroup.add(cholesterol);

             if (x > 15) { // 只给一个胆固醇添加标签
                cholesterol.userData.labelInfo = {
                    element: labelDiv,
                    object: cholesterol,
                    text: `<b>胆固醇 (Cholesterol)</b><br>镶嵌在磷脂分子间，调节膜的流动性。`
                };
                interactiveObjects.push(cholesterol);
            }
        }

        // 创建蛋白质
        // 1. 整合蛋白（通道蛋白）
        const channelProtein = new THREE.Mesh(new THREE.TorusGeometry(2, 1, 16, 50), integralProteinMaterial);
        channelProtein.rotation.x = Math.PI / 2;
        channelProtein.scale.z = 2.5; // 拉伸成椭圆通道
        membraneGroup.add(channelProtein);
        channelProtein.userData.labelInfo = {
            element: labelDiv,
            object: channelProtein,
            text: `<b>整合蛋白 (Integral Protein)</b><br>贯穿或嵌入磷脂双分子层，<br>作为物质运输的通道或受体。`
        };
        interactiveObjects.push(channelProtein);


        // 2. 糖蛋白 (Glycoprotein)
        const glycoproteinBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 5, 32), integralProteinMaterial);
        glycoproteinBase.position.set(7, 0, 0);
        membraneGroup.add(glycoproteinBase);
        glycoproteinBase.userData.labelInfo = {
            element: labelDiv,
            object: glycoproteinBase,
            text: `<b>糖蛋白 (Glycoprotein)</b><br>由蛋白质和糖链构成，<br>在细胞识别、免疫中起重要作用。`
        };
        interactiveObjects.push(glycoproteinBase);
        
        // 创建糖链
        const carbohydrateChain = new THREE.Group();
        let currentPos = new THREE.Vector3(0, 3, 0);
        for(let i=0; i<8; i++){
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), carbohydrateMaterial);
            sphere.position.copy(currentPos);
            carbohydrateChain.add(sphere);
            currentPos.x += (Math.random() - 0.5) * 1.5;
            currentPos.y += 0.6;
            currentPos.z += (Math.random() - 0.5) * 1.5;
        }
        glycoproteinBase.add(carbohydrateChain);

        // 3. 外周蛋白
        const peripheralProtein = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 16), peripheralProteinMaterial);
        peripheralProtein.scale.y = 0.5; // 压扁
        peripheralProtein.position.set(-8, 3.5, 8);
        membraneGroup.add(peripheralProtein);
        peripheralProtein.userData.labelInfo = {
            element: labelDiv,
            object: peripheralProtein,
            text: `<b>外周蛋白 (Peripheral Protein)</b><br>附着在膜的内外表面，<br>常作为酶或参与信号传导。`
        };
        interactiveObjects.push(peripheralProtein);

        scene.add(membraneGroup);

        // 5. 事件监听器
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onMouseMove, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseMove(event) {
            // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        const clock = new THREE.Clock();
        
        // 6. 动画循环
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // 模拟流动性
            membraneGroup.children.forEach(child => {
                if (child.children.length > 0 && child.position.y === 0) { // 判断是磷脂group
                     child.position.y = Math.sin(elapsedTime * 2 + child.position.x) * 0.2;
                }
            });
            
            // 射线投射检测
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects);

            if (intersects.length > 0) {
                if (intersectedObject !== intersects[0].object) {
                    intersectedObject = intersects[0].object;
                    const labelInfo = intersectedObject.userData.labelInfo;
                    if (labelInfo) {
                        labelDiv.innerHTML = labelInfo.text;
                        labelDiv.classList.add('visible');
                    }
                }
                 // 更新标签位置
                const vector = new THREE.Vector3();
                intersectedObject.getWorldPosition(vector);
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

                labelDiv.style.left = `${x + 15}px`;
                labelDiv.style.top = `${y - 15}px`;

            } else {
                if (intersectedObject) {
                    labelDiv.classList.remove('visible');
                }
                intersectedObject = null;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>