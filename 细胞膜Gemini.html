<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D细胞膜流动镶嵌模型</title>
    <style>
        body { margin: 0; background-color: #111; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 1px solid #555;
            max-width: 250px;
            display: none; /* Initially hidden */
        }
        #info-panel h3 { margin-top: 0; color: #00aaff; }
        #info-panel p { margin-bottom: 0; line-height: 1.5; }
    </style>
</head>
<body>

    <div id="info-panel">
        <h3 id="info-title">组件名称</h3>
        <p id="info-description">这里是组件的详细解释。</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. 场景设置 (Scene Setup) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true }); // antialias: true 开启抗锯齿，使边缘更平滑
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111111); // 设置背景颜色
        document.body.appendChild(renderer.domElement);

        // --- 2. 交互控制 (Controls) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 启用阻尼效果，使旋转更平滑
        controls.minDistance = 5; // 最小缩放距离
        controls.maxDistance = 50; // 最大缩放距离

        // --- 3. 光源设置 (Lighting) - 这是实现反光和细节的关键 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // 环境光，整体提亮
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // 平行光，模拟太阳光，产生阴影和高光
        directionalLight.position.set(10, 20, 5);
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x00aaff, 0.8, 100); // 点光源，增加局部光照和反光点
        pointLight.position.set(-15, 10, -10);
        scene.add(pointLight);


        // --- 4. 创建生物分子模型 (Creating Molecules) ---

        // 材质定义 (Materials) - 定义了颜色和反光属性
        const headMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90e2, // 亲水头部: 蓝色
            metalness: 0.3,   // 金属感
            roughness: 0.2    // 粗糙度，越小越反光
        });

        const tailMaterial = new THREE.MeshStandardMaterial({
            color: 0xf8f8f8, // 疏水尾部: 灰白色
            metalness: 0.1,
            roughness: 0.8
        });

        const proteinMaterial = new THREE.MeshStandardMaterial({
            color: 0x9013fe, // 蛋白质: 紫色
            metalness: 0.5,
            roughness: 0.3
        });
        
        const cholesterolMaterial = new THREE.MeshStandardMaterial({
            color: 0xf5a623, // 胆固醇: 橙黄色
            metalness: 0.6,
            roughness: 0.4
        });

        // 4.1 创建单个磷脂分子函数
        function createPhospholipid(x, z) {
            const group = new THREE.Group();
            
            // 亲水头部
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 16);
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2;
            group.add(head);
            head.userData = { type: '磷脂分子头（亲水）', description: '由磷酸基团构成，具有亲水性，朝向细胞内外侧的水性环境。' };


            // 疏水尾部 (两条)
            const tailShape1 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 1.8, 0),
                new THREE.Vector3(0.1, 0.5, 0),
                new THREE.Vector3(-0.2, -0.5, 0)
            ]);
            const tailShape2 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 1.8, 0),
                new THREE.Vector3(-0.1, 0.5, 0.1),
                new THREE.Vector3(0.2, -0.5, 0.1)
            ]);
            const tailGeometry1 = new THREE.TubeGeometry(tailShape1, 20, 0.1, 8, false);
            const tailGeometry2 = new THREE.TubeGeometry(tailShape2, 20, 0.1, 8, false);
            const tail1 = new THREE.Mesh(tailGeometry1, tailMaterial);
            const tail2 = new THREE.Mesh(tailGeometry2, tailMaterial);
            group.add(tail1, tail2);
            tail1.userData = tail2.userData = { type: '磷脂分子尾（疏水）', description: '由脂肪酸链构成，具有疏水性，藏在膜的内部，避开水性环境。' };

            group.position.set(x, 0, z);
            return group;
        }

        // 4.2 创建磷脂双分子层
        const membrane = new THREE.Group();
        const size = 15; // 膜的尺寸
        for (let i = -size; i <= size; i++) {
            for (let j = -size; j <= size; j++) {
                // 跳过中心区域，为蛋白质留出空间
                if (Math.abs(i) < 4 && Math.abs(j) < 4) continue;

                // 上层
                const lipid1 = createPhospholipid(i, j);
                lipid1.position.y = (Math.random() - 0.5) * 0.2; // 模拟流动性
                membrane.add(lipid1);
                
                // 下层 (旋转180度)
                const lipid2 = createPhospholipid(i, j);
                lipid2.rotation.z = Math.PI;
                lipid2.position.y = (Math.random() - 0.5) * 0.2; // 模拟流动性
                membrane.add(lipid2);
            }
        }
        membrane.userData = { type: '磷脂双分子层', description: '构成细胞膜的基本骨架，具有流动性，决定了膜的基本特性。' };
        scene.add(membrane);

        // 4.3 创建镶嵌蛋白质
        const proteinGeometry = new THREE.CylinderGeometry(2.5, 3, 7, 32);
        const protein = new THREE.Mesh(proteinGeometry, proteinMaterial);
        protein.position.set(0, 0, 0);
        protein.userData = { type: '整合蛋白（通道蛋白）', description: '贯穿磷脂双分子层，作为物质跨膜运输的通道，具有选择性。' };
        scene.add(protein);
        
        // 4.4 创建胆固醇
        for (let i = 0; i < 20; i++) {
            const cholesterolGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const cholesterol = new THREE.Mesh(cholesterolGeometry, cholesterolMaterial);
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 5 + 5;
            cholesterol.position.set(Math.cos(angle) * radius, (Math.random() > 0.5 ? 1.5 : -1.5), Math.sin(angle) * radius);
            cholesterol.rotation.set(Math.random(), Math.random(), Math.random());
            cholesterol.userData = { type: '胆固醇', description: '镶嵌在磷脂分子之间，调节膜的流动性。温度高时降低流动性，温度低时防止固化。' };
            scene.add(cholesterol);
        }


        // --- 5. 交互实现 (Interactivity) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const infoPanel = document.getElementById('info-panel');
        const infoTitle = document.getElementById('info-title');
        const infoDescription = document.getElementById('info-description');
        let intersectedObject = null;

        window.addEventListener('mousemove', onMouseMove);

        function onMouseMove(event) {
            // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to 1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function checkIntersection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // 寻找第一个有userData的父对象
                let target = intersects[0].object;
                while (target && !target.userData.type) {
                    target = target.parent;
                }

                if (target && target.userData.type) {
                    if (intersectedObject !== target) {
                        intersectedObject = target;
                        infoTitle.textContent = intersectedObject.userData.type;
                        infoDescription.textContent = intersectedObject.userData.description;
                        infoPanel.style.display = 'block';
                    }
                } else {
                    hideInfo();
                }
            } else {
                hideInfo();
            }
        }
        
        function hideInfo() {
            if (intersectedObject) {
                intersectedObject = null;
                infoPanel.style.display = 'none';
            }
        }
        
        // --- 6. 动画循环 (Animation Loop) ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新控制器

            // 检测鼠标交互
            checkIntersection();

            // 给模型增加一点点流动的动画
            membrane.children.forEach(lipid => {
                lipid.position.x += (Math.random() - 0.5) * 0.005;
                lipid.position.z += (Math.random() - 0.5) * 0.005;
            });

            renderer.render(scene, camera);
        }

        // --- 7. 窗口大小自适应 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>